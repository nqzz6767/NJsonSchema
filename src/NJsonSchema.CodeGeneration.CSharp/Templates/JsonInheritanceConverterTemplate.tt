<#@ template visibility="internal" #>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "<#=JsonSchema4.ToolchainVersion#>")]
internal class JsonInheritanceConverter : Newtonsoft.Json.JsonConverter
{
    internal static readonly string DefaultDiscriminatorName = "discriminator";

    private readonly string _discriminator;
        
    [System.ThreadStatic]
    private static bool _isReading;

    [System.ThreadStatic]
    private static bool _isWriting;

    public JsonInheritanceConverter()
    {
        _discriminator = DefaultDiscriminatorName;
    }

    public JsonInheritanceConverter(string discriminator)
    {
        _discriminator = discriminator;
    }

    public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer)
    {
        try
        {
            _isWriting = true;

            var jObject = Newtonsoft.Json.Linq.JObject.FromObject(value, serializer);
            jObject.AddFirst(new Newtonsoft.Json.Linq.JProperty(_discriminator, value.GetType().Name));
            writer.WriteToken(jObject.CreateReader());
        }
        finally
        {
            _isWriting = false;
        }
    }

    public override bool CanWrite
    {
        get
        {
            if (_isWriting)
            {
                _isWriting = false;
                return false; 
            }
            return true;
        }
    }

    public override bool CanRead
    {
        get
        {
            if (_isReading)
            {
                _isReading = false;
                return false;
            }
            return true;
        }
    }

    public override bool CanConvert(System.Type objectType)
    {
        return true;
    }

    public override object ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer)
    {
        var jObject = serializer.Deserialize<Newtonsoft.Json.Linq.JObject>(reader);
        if (jObject == null)
            return null;

        var discriminator = Newtonsoft.Json.Linq.Extensions.Value<string>(jObject.GetValue(_discriminator));
        var subtype = GetObjectSubtype(jObject, objectType, discriminator);

        try
        {
            _isReading = true;
            return serializer.Deserialize(jObject.CreateReader(), subtype);
        }
        finally
        {
            _isReading = false;
        }
    }

    private System.Type GetObjectSubtype(Newtonsoft.Json.Linq.JObject jObject, System.Type objectType, string discriminator)
    {
        if (objectType.Name == discriminator)
            return objectType;

        var knownTypeAttributesSubtype = GetSubtypeFromKnownTypeAttributes(objectType, discriminator);
        if (knownTypeAttributesSubtype != null)
            return knownTypeAttributesSubtype;

        var typeName = objectType.Namespace + "." + discriminator;
        var subtype = System.Reflection.IntrospectionExtensions.GetTypeInfo(objectType).Assembly.GetType(typeName);
        if (subtype != null)
            return subtype;

        var typeInfo = jObject.GetValue("$type");
        if (typeInfo != null)
            return System.Type.GetType(Newtonsoft.Json.Linq.Extensions.Value<string>(typeInfo));

        throw new System.InvalidOperationException("Could not find subtype of '" + objectType.Name + "' with discriminator '" + discriminator + "'.");
    }

    private System.Type GetSubtypeFromKnownTypeAttributes(System.Type objectType, string discriminator)
    {
        var type = objectType;
        do
        {
            var knownTypeAttributes = System.Reflection.IntrospectionExtensions.GetTypeInfo(type).GetCustomAttributes(false)
				.Where(a => a.GetType().Name == "KnownTypeAttribute");
            foreach (dynamic attribute in knownTypeAttributes)
            {
                if (attribute.Type != null && attribute.Type.Name == discriminator)
                    return attribute.Type;
                else if (attribute.MethodName != null)
                {
                    var method = System.Reflection.RuntimeReflectionExtensions.GetRuntimeMethod(type, (string)attribute.MethodName, new System.Type[0]);
                    if (method != null)
                    {
                        var types = (System.Collections.Generic.IEnumerable<System.Type>)method.Invoke(null, new object[0]);
                        foreach (var knownType in types)
                        {
                            if (knownType.Name == discriminator)
                                return knownType;
                        }
                        return null;
                    }
                }
            }
            type = System.Reflection.IntrospectionExtensions.GetTypeInfo(type).BaseType;
        } while (type != null);
        return null;
    }
}